================================================================
RepopackPy Output File
================================================================

This file was generated by RepopackPy on: 2025-06-18T22:02:07.676816

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and RepopackPy's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

For more information about RepopackPy, visit: https://github.com/abinthomasonline/repopack-py

================================================================
Repository Structure
================================================================
PerftBenchmark.cpp
bitboard.cpp
bitboard.h
example.py
magicmoves.c
magicmoves.h
magicmoves_wrapper.h
move.h
piece.h
position.cpp
python_bindings.cpp
setup.py
types.h

================================================================
Repository Files
================================================================

================
File: magicmoves.h
================
/**
 *magicmoves.h
 *
 *Header file for magic move bitboard generation.  Include this in any files
 *need this functionality.
 *
 *Usage:
 *You must first initialize the generator with a call to initmagicmoves().
 *Then you can use the following macros for generating move bitboards by
 *giving them a square and an occupancy.  The macro will then "return"
 *the correct move bitboard for that particular square and occupancy. It
 *has been named Rmagic and Bmagic so that it will not conflict with
 *any functions/macros in your chess program called Rmoves/Bmoves. You
 *can macro Bmagic/Rmagic to Bmoves/Rmoves if you wish.  If you want to
 *minimize the size of the bitboards, make MINIMIZE_MAGIC uncommented in this
 *header (more info on this later).  Where you typedef your unsigned 64-bit
 *integer declare __64_BIT_INTEGER_DEFINED__.  If USE_INLINING is uncommented,
 *the macros will be expressed as MMINLINEd functions.  If PERFECT_MAGIC_HASH is
 *uncomment, the move generator will use an additional indrection to make the
 *table sizes smaller : (~50kb+((original size)/sizeof(PERFECT_MAGIC_HASH)).
 *The size listed from here on out are the sizes without PERFECT_MAGIC_HASH.
 *
 *Bmagic(square, occupancy)
 *Rmagic(square, occupancy)
 *
 *Square is an integer that is greater than or equal to zero and less than 64.
 *Occupancy is any unsigned 64-bit integer that describes which squares on
 *the board are occupied.
 *
 *The following macros are identical to Rmagic and Bmagic except that the 
 *occupancy is assumed to already have been "masked".  Look at the following
 *source or read up on the internet about magic bitboard move generation to
 *understand the usage of these macros and what it means by "an occupancy that
 *has already been masked".  Using the following macros when possible might be
 *a tiny bit faster than using Rmagic and Bmagic because it avoids an array
 *access and a 64-bit & operation.
 *
 *BmagicNOMASK(square, occupancy)
 *RmagicNOMASK(square, occupancy)
 *
 *Unsigned 64 bit integers are referenced by this generator as U64.
 *Edit the beginning lines of this header for the defenition of a 64 bit
 *integer if necessary.
 *
 *If MINIMIZE_MAGIC is defined before including this file:
 *The move bitboard generator will use up 841kb of memory.
 *41kb of memory is used for the bishop database and 800kb is used for the rook
 *database.  If you feel the 800kb rook database is too big, then comment it out
 *and use a more traditional move bitboard generator in conjunction with the
 *magic move bitboard generator for bishops.
 *
 *If MINIMIAZE_MAGIC is not defined before including this file:
 *The move bitboard generator will use up 2304kb of memory but might perform a bit
 *faster.
 *
 *Copyright (C) 2007 Pradyumna Kannan.
 *
 *This code is provided 'as-is', without any expressed or implied warranty.
 *In no event will the authors be held liable for any damages arising from
 *the use of this code. Permission is granted to anyone to use this
 *code for any purpose, including commercial applications, and to alter
 *it and redistribute it freely, subject to the following restrictions:
 *
 *1. The origin of this code must not be misrepresented; you must not
 *claim that you wrote the original code. If you use this code in a
 *product, an acknowledgment in the product documentation would be
 *appreciated but is not required.
 *
 *2. Altered source versions must be plainly marked as such, and must not be
 *misrepresented as being the original code.
 *
 *3. This notice may not be removed or altered from any source distribution.
 */

#ifndef _magicmovesh
#define _magicmovesh

/*********MODIFY THE FOLLOWING IF NECESSARY********/
//the default configuration is the best

//Uncommont either one of the following or none
#define MINIMIZE_MAGIC
//#define PERFECT_MAGIC_HASH unsigned short

//the following works only for perfect magic hash or no defenitions above
//it uses variable shift for each square
//#define VARIABLE_SHIFT

#define USE_INLINING /*the MMINLINE keyword is assumed to be available*/

#ifndef __64_BIT_INTEGER_DEFINED__
	#define __64_BIT_INTEGER_DEFINED__
	#if defined(_MSC_VER) && _MSC_VER<1300
		typedef unsigned __int64 U64; //For the old microsoft compilers
	#else
		typedef unsigned long long  U64; //Supported by MSC 13.00+ and C99
	#endif //defined(_MSC_VER) && _MSC_VER<1300
#endif //__64_BIT_INTEGER_DEFINED__
/***********MODIFY THE ABOVE IF NECESSARY**********/

/*Defining the inlining keyword*/
#ifdef USE_INLINING
	#ifdef _MSC_VER
		#define MMINLINE __forceinline
	#elif defined(__GNUC__)
		#define MMINLINE __inline__ __attribute__((always_inline))
	#else
		#define MMINLINE inline
	#endif
#endif

#ifndef C64
	#if (!defined(_MSC_VER) || _MSC_VER>1300)
		#define C64(constantU64) constantU64##ULL
	#else
		#define C64(constantU64) constantU64
	#endif
#endif

extern const U64 magicmoves_r_magics[64];
extern const U64 magicmoves_r_mask[64];
extern const U64 magicmoves_b_magics[64];
extern const U64 magicmoves_b_mask[64];
extern const unsigned int magicmoves_b_shift[64];
extern const unsigned int magicmoves_r_shift[64];

#ifndef VARIABLE_SHIFT
	#define MINIMAL_B_BITS_SHIFT(square) 55
	#define MINIMAL_R_BITS_SHIFT(square) 52
#else
	#define MINIMAL_B_BITS_SHIFT(square) magicmoves_b_shift[square]
	#define MINIMAL_R_BITS_SHIFT(square) magicmoves_r_shift[square]
#endif

#ifndef PERFECT_MAGIC_HASH
	#ifdef MINIMIZE_MAGIC

		#ifndef USE_INLINING
			#define Bmagic(square, occupancy) *(magicmoves_b_indices[square]+((((occupancy)&magicmoves_b_mask[square])*magicmoves_b_magics[square])>>magicmoves_b_shift[square]))
			#define Rmagic(square, occupancy) *(magicmoves_r_indices[square]+((((occupancy)&magicmoves_r_mask[square])*magicmoves_r_magics[square])>>magicmoves_r_shift[square]))
			#define BmagicNOMASK(square, occupancy) *(magicmoves_b_indices[square]+(((occupancy)*magicmoves_b_magics[square])>>magicmoves_b_shift[square]))
			#define RmagicNOMASK(square, occupancy) *(magicmoves_r_indices[square]+(((occupancy)*magicmoves_r_magics[square])>>magicmoves_r_shift[square]))
		#endif //USE_INLINING

		//extern U64 magicmovesbdb[5248];
		extern const U64* magicmoves_b_indices[64];

		//extern U64 magicmovesrdb[102400];
		extern const U64* magicmoves_r_indices[64];

	#else //Don't Minimize database size

		#ifndef USE_INLINING
			#define Bmagic(square, occupancy) magicmovesbdb[square][(((occupancy)&magicmoves_b_mask[square])*magicmoves_b_magics[square])>>MINIMAL_B_BITS_SHIFT(square)]
			#define Rmagic(square, occupancy) magicmovesrdb[square][(((occupancy)&magicmoves_r_mask[square])*magicmoves_r_magics[square])>>MINIMAL_R_BITS_SHIFT(square)]
			#define BmagicNOMASK(square, occupancy) magicmovesbdb[square][((occupancy)*magicmoves_b_magics[square])>>MINIMAL_B_BITS_SHIFT(square)]
			#define RmagicNOMASK(square, occupancy) magicmovesrdb[square][((occupancy)*magicmoves_r_magics[square])>>MINIMAL_R_BITS_SHIFT(square)]
		#endif //USE_INLINING

		extern U64 magicmovesbdb[64][1<<9];
		extern U64 magicmovesrdb[64][1<<12];

	#endif //MINIMIAZE_MAGICMOVES
#else //PERFCT_MAGIC_HASH defined
	#ifndef MINIMIZE_MAGIC

		#ifndef USE_INLINING
			#define Bmagic(square, occupancy) magicmovesbdb[magicmoves_b_indices[square][(((occupancy)&magicmoves_b_mask[square])*magicmoves_b_magics[square])>>MINIMAL_B_BITS_SHIFT(square)]]
			#define Rmagic(square, occupancy) magicmovesrdb[magicmoves_r_indices[square][(((occupancy)&magicmoves_r_mask[square])*magicmoves_r_magics[square])>>MINIMAL_R_BITS_SHIFT(square)]]
			#define BmagicNOMASK(square, occupancy) magicmovesbdb[magicmoves_b_indices[square][((occupancy)*magicmoves_b_magics[square])>>MINIMAL_B_BITS_SHIFT(square)]]
			#define RmagicNOMASK(square, occupancy) magicmovesrdb[magicmoves_r_indices[square][((occupancy)*magicmoves_r_magics[square])>>MINIMAL_R_BITS_SHIFT(square)]]
		#endif //USE_INLINING

		extern U64 magicmovesbdb[1428];
		extern U64 magicmovesrdb[4900];
		extern PERFECT_MAGIC_HASH magicmoves_b_indices[64][1<<9];
		extern PERFECT_MAGIC_HASH magicmoves_r_indices[64][1<<12];
	#else
		#error magicmoves - MINIMIZED_MAGIC and PERFECT_MAGIC_HASH cannot be used together
	#endif
#endif //PERFCT_MAGIC_HASH

#ifdef USE_INLINING
	static MMINLINE U64 Bmagic(const unsigned int square,const U64 occupancy)
	{
		#ifndef PERFECT_MAGIC_HASH
			#ifdef MINIMIZE_MAGIC
				return *(magicmoves_b_indices[square]+(((occupancy&magicmoves_b_mask[square])*magicmoves_b_magics[square])>>magicmoves_b_shift[square]));
			#else
				return magicmovesbdb[square][(((occupancy)&magicmoves_b_mask[square])*magicmoves_b_magics[square])>>MINIMAL_B_BITS_SHIFT(square)];
			#endif
		#else
			return magicmovesbdb[magicmoves_b_indices[square][(((occupancy)&magicmoves_b_mask[square])*magicmoves_b_magics[square])>>MINIMAL_B_BITS_SHIFT(square)]];
		#endif
	}
	static MMINLINE U64 Rmagic(const unsigned int square,const U64 occupancy)
	{
		#ifndef PERFECT_MAGIC_HASH
			#ifdef MINIMIZE_MAGIC
				return *(magicmoves_r_indices[square]+(((occupancy&magicmoves_r_mask[square])*magicmoves_r_magics[square])>>magicmoves_r_shift[square]));
			#else
				return magicmovesrdb[square][(((occupancy)&magicmoves_r_mask[square])*magicmoves_r_magics[square])>>MINIMAL_R_BITS_SHIFT(square)];
			#endif
		#else
			return magicmovesrdb[magicmoves_r_indices[square][(((occupancy)&magicmoves_r_mask[square])*magicmoves_r_magics[square])>>MINIMAL_R_BITS_SHIFT(square)]];
		#endif
	}
	static MMINLINE U64 BmagicNOMASK(const unsigned int square,const U64 occupancy)
	{
		#ifndef PERFECT_MAGIC_HASH
			#ifdef MINIMIZE_MAGIC
				return *(magicmoves_b_indices[square]+(((occupancy)*magicmoves_b_magics[square])>>magicmoves_b_shift[square]));
			#else
				return magicmovesbdb[square][((occupancy)*magicmoves_b_magics[square])>>MINIMAL_B_BITS_SHIFT(square)];
			#endif
		#else
			return magicmovesbdb[magicmoves_b_indices[square][((occupancy)*magicmoves_b_magics[square])>>MINIMAL_B_BITS_SHIFT(square)]];
		#endif
	}
	static MMINLINE U64 RmagicNOMASK(const unsigned int square, const U64 occupancy)
	{
		#ifndef PERFECT_MAGIC_HASH
			#ifdef MINIMIZE_MAGIC
				return *(magicmoves_r_indices[square]+(((occupancy)*magicmoves_r_magics[square])>>magicmoves_r_shift[square]));
			#else
				return magicmovesrdb[square][((occupancy)*magicmoves_r_magics[square])>>MINIMAL_R_BITS_SHIFT(square)];
			#endif
		#else
			return magicmovesrdb[magicmoves_r_indices[square][((occupancy)*magicmoves_r_magics[square])>>MINIMAL_R_BITS_SHIFT(square)]];
		#endif
	}

	static MMINLINE U64 Qmagic(const unsigned int square,const U64 occupancy)
	{
		return Bmagic(square,occupancy)|Rmagic(square,occupancy);
	}
	static MMINLINE U64 QmagicNOMASK(const unsigned int square, const U64 occupancy)
	{
		return BmagicNOMASK(square,occupancy)|RmagicNOMASK(square,occupancy);
	}
#else //!USE_INLINING

#define Qmagic(square, occupancy) (Bmagic(square,occupancy)|Rmagic(square,occupancy))
#define QmagicNOMASK(square, occupancy) (BmagicNOMASK(square,occupancy)|RmagicNOMASK(square,occupancy))

#endif //USE_INLINING

void initmagicmoves(void);

#endif //_magicmoveshvesh

================
File: types.h
================
// types.h
#pragma once
#include <cstdint>

using U64 = uint64_t;
using Square = int;
using Bitboard = uint64_t;

enum PieceType : int {
    PAWN = 0, KNIGHT = 1, BISHOP = 2, ROOK = 3, QUEEN = 4, KING = 5
};

enum Color : int {
    WHITE = 0, BLACK = 1
};

================
File: piece.h
================
#include <cstdint>

class Piece {
private:
    uint8_t data;  // 4 bits: type (0-6), 1 bit: color, 3 bits: unused, use 8 bits for memory efficiency
    
public:
    static constexpr uint8_t TYPE_MASK = 0x07;   // 0b00000111
    static constexpr uint8_t COLOR_MASK = 0x08;  // 0b00001000
    
    enum Type : uint8_t {
        NONE = 0, PAWN = 1, KNIGHT = 2, BISHOP = 3,
        ROOK = 4, QUEEN = 5, KING = 6
    };
    
    enum Color : uint8_t {
        WHITE = 0, BLACK = 8
    };
    
    constexpr Piece() : data(0) {}
    constexpr Piece(Color color, Type type) : data(color | type) {}
    
    constexpr Type type() const { return Type(data & TYPE_MASK); }
    constexpr Color color() const { return Color(data & COLOR_MASK); }
    constexpr bool is_empty() const { return data == 0; }
    constexpr uint8_t raw() const { return data; }
    
    constexpr bool operator==(Piece other) const { return data == other.data; }
    constexpr bool operator!=(Piece other) const { return data != other.data; }
};

================
File: bitboard.cpp
================
#include "bitboard.h"
#include <algorithm>

ChessBitboard::ChessBitboard() {
    // Initialize all bitboards to 0
    white_pawns = white_knights = white_bishops = 0;
    white_rooks = white_queens = white_king = 0;
    black_pawns = black_knights = black_bishops = 0;
    black_rooks = black_queens = black_king = 0;
    
    white_to_move = true;
    //use 4 bits here since only 4 possible castles: queenside, kingside etc
    castling_rights = 0b1111;
    en_passant_square = -1;
    halfmove_clock = 0;
    fullmove_number = 1;
    
    // Clear mailbox
    for (int i = 0; i < 64; i++) {
        mailbox[i] = Piece();
    }
    
    // Initialize magic bitboards
    MagicMoves::init();
}

Bitboard ChessBitboard::getWhitePieces() const {
    return white_pawns | white_knights | white_bishops | white_rooks | white_queens | white_king;
}

Bitboard ChessBitboard::getBlackPieces() const {
    return black_pawns | black_knights | black_bishops | black_rooks | black_queens | black_king;
}

Bitboard ChessBitboard::getAllPieces() const {
    return getWhitePieces() | getBlackPieces();
}

void ChessBitboard::setStartingPosition() {
    // White pieces
    white_pawns = 0x000000000000FF00ULL;
    white_rooks = 0x0000000000000081ULL;
    white_knights = 0x0000000000000042ULL;
    white_bishops = 0x0000000000000024ULL;
    white_queens = 0x0000000000000008ULL;
    white_king = 0x0000000000000010ULL;
    
    // Black pieces
    black_pawns = 0x00FF000000000000ULL;
    black_rooks = 0x8100000000000000ULL;
    black_knights = 0x4200000000000000ULL;
    black_bishops = 0x2400000000000000ULL;
    black_queens = 0x0800000000000000ULL;
    black_king = 0x1000000000000000ULL;
    
    white_to_move = true;
    castling_rights = 0b1111;
    en_passant_square = -1;
    halfmove_clock = 0;
    fullmove_number = 1;
    
    updateMailbox();
}

Piece ChessBitboard::getPieceAt(Square square) const {
    return mailbox[square];
}

void ChessBitboard::setPiece(Square square, Piece piece) {
    // Clear the square first
    clearSquare(square);
    
    // Set the piece in mailbox
    mailbox[square] = piece;
    
    // Set the corresponding bitboard
    if (!piece.is_empty()) {
        addPieceToBitboard(square, piece);
    }
}

void ChessBitboard::clearSquare(Square square) {
    Piece old_piece = mailbox[square];
    if (!old_piece.is_empty()) {
        removePieceFromBitboard(square, old_piece);
    }
    mailbox[square] = Piece();
}

Bitboard ChessBitboard::getAttacks(Square square, PieceType piece_type, Bitboard occupancy) const {
    switch (piece_type) {
        case ROOK:
            return MagicMoves::getRookAttacks(square, occupancy);
        case BISHOP:
            return MagicMoves::getBishopAttacks(square, occupancy);
        case QUEEN:
            return MagicMoves::getQueenAttacks(square, occupancy);
        default:
            return 0ULL; // Handle other pieces separately
    }
}

std::vector<Move> ChessBitboard::generatePseudoLegalMoves() const {
    std::vector<Move> moves;
    moves.reserve(256); // Pre-allocate for performance
    
    Bitboard occupancy = getAllPieces();
    Bitboard friendly = white_to_move ? getWhitePieces() : getBlackPieces();
    Bitboard enemy = white_to_move ? getBlackPieces() : getWhitePieces();
    
    // Generate moves for each piece type
    Bitboard pieces = white_to_move ? white_rooks : black_rooks;
    while (pieces) {
        Square from = __builtin_ctzll(pieces); // Get LSB
        pieces &= pieces - 1; // Clear LSB
        
        Bitboard attacks = MagicMoves::getRookAttacks(from, occupancy);
        attacks &= ~friendly; // Can't capture own pieces
        
        while (attacks) {
            Square to = __builtin_ctzll(attacks);
            attacks &= attacks - 1;
            moves.emplace_back(from, to, ROOK);
        }
    }
    
    // Similar for bishops
    pieces = white_to_move ? white_bishops : black_bishops;
    while (pieces) {
        Square from = __builtin_ctzll(pieces);
        pieces &= pieces - 1;
        
        Bitboard attacks = MagicMoves::getBishopAttacks(from, occupancy);
        attacks &= ~friendly;
        
        while (attacks) {
            Square to = __builtin_ctzll(attacks);
            attacks &= attacks - 1;
            moves.emplace_back(from, to, BISHOP);
        }
    }
    
    // Queens
    pieces = white_to_move ? white_queens : black_queens;
    while (pieces) {
        Square from = __builtin_ctzll(pieces);
        pieces &= pieces - 1;
        
        Bitboard attacks = MagicMoves::getQueenAttacks(from, occupancy);
        attacks &= ~friendly;
        
        while (attacks) {
            Square to = __builtin_ctzll(attacks);
            attacks &= attacks - 1;
            moves.emplace_back(from, to, QUEEN);
        }
    }
    
    // TODO: Add pawn, knight, king moves
    
    return moves;
}

std::vector<Move> ChessBitboard::generateLegalMoves() const {
    std::vector<Move> pseudo_legal = generatePseudoLegalMoves();
    std::vector<Move> legal_moves;
    legal_moves.reserve(pseudo_legal.size());
    
    for (const Move& move : pseudo_legal) {
        if (isLegal(move)) {
            legal_moves.push_back(move);
        }
    }
    
    return legal_moves;
}

void ChessBitboard::makeMove(const Move& move) {
    Piece moving_piece = getPieceAt(move.from());
    Piece captured_piece = getPieceAt(move.to());
    
    // Move the piece
    clearSquare(move.from());
    setPiece(move.to(), moving_piece);
    
    // Update game state
    white_to_move = !white_to_move;
    
    // TODO: Handle castling, en passant, promotion
    // TODO: Update castling rights based on move
    // TODO: Update halfmove clock
    if (white_to_move) fullmove_number++;
}

bool ChessBitboard::isLegal(const Move& move) const {
    // Create a copy and make the move
    ChessBitboard temp = *this;
    temp.makeMove(move);
    
    // Check if our king is in check after the move
    Bitboard king_bb = white_to_move ? temp.white_king : temp.black_king;
    Square king_square = __builtin_ctzll(king_bb);
    
    // TODO: Check if king is attacked by opponent pieces
    // This requires implementing attack generation for all piece types
    
    return true; // Placeholder - implement proper check detection
}

// Helper methods
void ChessBitboard::updateMailbox() {
    // Clear mailbox
    for (int i = 0; i < 64; i++) {
        mailbox[i] = Piece();
    }
    
    // Update from bitboards
    for (int square = 0; square < 64; square++) {
        Bitboard mask = 1ULL << square;
        
        if (white_pawns & mask) mailbox[square] = Piece(Piece::WHITE, Piece::PAWN);
        else if (white_knights & mask) mailbox[square] = Piece(Piece::WHITE, Piece::KNIGHT);
        else if (white_bishops & mask) mailbox[square] = Piece(Piece::WHITE, Piece::BISHOP);
        else if (white_rooks & mask) mailbox[square] = Piece(Piece::WHITE, Piece::ROOK);
        else if (white_queens & mask) mailbox[square] = Piece(Piece::WHITE, Piece::QUEEN);
        else if (white_king & mask) mailbox[square] = Piece(Piece::WHITE, Piece::KING);
        
        else if (black_pawns & mask) mailbox[square] = Piece(Piece::BLACK, Piece::PAWN);
        else if (black_knights & mask) mailbox[square] = Piece(Piece::BLACK, Piece::KNIGHT);
        else if (black_bishops & mask) mailbox[square] = Piece(Piece::BLACK, Piece::BISHOP);
        else if (black_rooks & mask) mailbox[square] = Piece(Piece::BLACK, Piece::ROOK);
        else if (black_queens & mask) mailbox[square] = Piece(Piece::BLACK, Piece::QUEEN);
        else if (black_king & mask) mailbox[square] = Piece(Piece::BLACK, Piece::KING);
    }
}

void ChessBitboard::addPieceToBitboard(Square square, Piece piece) {
    Bitboard mask = 1ULL << square;
    
    if (piece.color() == Piece::WHITE) {
        switch (piece.type()) {
            case Piece::PAWN: white_pawns |= mask; break;
            case Piece::KNIGHT: white_knights |= mask; break;
            case Piece::BISHOP: white_bishops |= mask; break;
            case Piece::ROOK: white_rooks |= mask; break;
            case Piece::QUEEN: white_queens |= mask; break;
            case Piece::KING: white_king |= mask; break;
        }
    } else {
        switch (piece.type()) {
            case Piece::PAWN: black_pawns |= mask; break;
            case Piece::KNIGHT: black_knights |= mask; break;
            case Piece::BISHOP: black_bishops |= mask; break;
            case Piece::ROOK: black_rooks |= mask; break;
            case Piece::QUEEN: black_queens |= mask; break;
            case Piece::KING: black_king |= mask; break;
        }
    }
}

void ChessBitboard::removePieceFromBitboard(Square square, Piece piece) {
    Bitboard mask = ~(1ULL << square);
    
    if (piece.color() == Piece::WHITE) {
        switch (piece.type()) {
            case Piece::PAWN: white_pawns &= mask; break;
            case Piece::KNIGHT: white_knights &= mask; break;
            case Piece::BISHOP: white_bishops &= mask; break;
            case Piece::ROOK: white_rooks &= mask; break;
            case Piece::QUEEN: white_queens &= mask; break;
            case Piece::KING: white_king &= mask; break;
        }
    } else {
        switch (piece.type()) {
            case Piece::PAWN: black_pawns &= mask; break;
            case Piece::KNIGHT: black_knights &= mask; break;
            case Piece::BISHOP: black_bishops &= mask; break;
            case Piece::ROOK: black_rooks &= mask; break;
            case Piece::QUEEN: black_queens &= mask; break;
            case Piece::KING: black_king &= mask; break;
        }
    }
}

================
File: PerftBenchmark.cpp
================
#include "position.cpp"
#include "bitboard.cpp"
#include "piece.cpp"
#include <cstdint>
#include <vector>
#include <iostream>

// PerftBenchmark is a class that contains the perft function
class PerftBenchmark {
public:
    uint64_t perft(const Position& pos, int depth) {
        if (depth == 0) return 1;
        
        uint64_t nodes = 0;
        auto moves = generate_all_moves(pos);
        
        for (auto move : moves) {
            Position new_pos = pos;
            new_pos.make_move(move);
            nodes += perft(new_pos, depth - 1);
        }
        
        return nodes;
    }
};

================
File: bitboard.h
================
#pragma once
#include "types.h"
#include "piece.h"
#include "move.h"
#include "magicmoves_wrapper.h"
#include <vector>

class ChessBitboard {
public:
    // Piece bitboards
    Bitboard white_pawns;
    Bitboard white_knights;
    Bitboard white_bishops;
    Bitboard white_rooks;
    Bitboard white_queens;
    Bitboard white_king;
    
    Bitboard black_pawns;
    Bitboard black_knights;
    Bitboard black_bishops;
    Bitboard black_rooks;
    Bitboard black_queens;
    Bitboard black_king;
    
    // Game state
    bool white_to_move;
    int castling_rights;
    int en_passant_square;
    int halfmove_clock;
    int fullmove_number;
    
    // Mailbox for fast piece lookup
    Piece mailbox[64];
    
    ChessBitboard();
    
    // Basic operations
    Bitboard getWhitePieces() const;
    Bitboard getBlackPieces() const;
    Bitboard getAllPieces() const;
    void setStartingPosition();
    
    // Piece operations
    Piece getPieceAt(Square square) const;
    void setPiece(Square square, Piece piece);
    void clearSquare(Square square);
    
    // Move generation
    std::vector<Move> generateLegalMoves() const;
    std::vector<Move> generatePseudoLegalMoves() const;
    
    // Move execution
    void makeMove(const Move& move);
    bool isLegal(const Move& move) const;
    
    // Attack generation using magic bitboards
    Bitboard getAttacks(Square square, PieceType piece_type, Bitboard occupancy) const;
    
private:
    void updateMailbox();
    void removePieceFromBitboard(Square square, Piece piece);
    void addPieceToBitboard(Square square, Piece piece);
};

================
File: magicmoves.c
================
/**
 *magicmoves.h
 *
 *Source file for magic move bitboard generation.
 *
 *See header file for instructions on usage.
 *
 *The magic keys are not optimal for all squares but they are very close
 *to optimal.
 *
 *Copyright (C) 2007 Pradyumna Kannan.
 *
 *This code is provided 'as-is', without any express or implied warranty.
 *In no event will the authors be held liable for any damages arising from
 *the use of this code. Permission is granted to anyone to use this
 *code for any purpose, including commercial applications, and to alter
 *it and redistribute it freely, subject to the following restrictions:
 *
 *1. The origin of this code must not be misrepresented; you must not
 *claim that you wrote the original code. If you use this code in a
 *product, an acknowledgment in the product documentation would be
 *appreciated but is not required.
 *
 *2. Altered source versions must be plainly marked as such, and must not be
 *misrepresented as being the original code.
 *
 *3. This notice may not be removed or altered from any source distribution.
 */

#include "magicmoves.h"

#ifdef _MSC_VER
	#pragma message("MSC compatible compiler detected -- turning off warning 4312,4146")
	#pragma warning( disable : 4312)
	#pragma warning( disable : 4146)
#endif

//For rooks

//original 12 bit keys
//C64(0x0000002040810402) - H8 12 bit
//C64(0x0000102040800101) - A8 12 bit
//C64(0x0000102040008101) - B8 11 bit
//C64(0x0000081020004101) - C8 11 bit

//Adapted Grant Osborne's keys
//C64(0x0001FFFAABFAD1A2) - H8 11 bit
//C64(0x00FFFCDDFCED714A) - A8 11 bit
//C64(0x007FFCDDFCED714A) - B8 10 bit
//C64(0x003FFFCDFFD88096) - C8 10 bit

const unsigned int magicmoves_r_shift[64]=
{
	52, 53, 53, 53, 53, 53, 53, 52,
	53, 54, 54, 54, 54, 54, 54, 53,
	53, 54, 54, 54, 54, 54, 54, 53,
	53, 54, 54, 54, 54, 54, 54, 53,
	53, 54, 54, 54, 54, 54, 54, 53,
	53, 54, 54, 54, 54, 54, 54, 53,
	53, 54, 54, 54, 54, 54, 54, 53,
	53, 54, 54, 53, 53, 53, 53, 53
};

const U64 magicmoves_r_magics[64]=
{
	C64(0x0080001020400080), C64(0x0040001000200040), C64(0x0080081000200080), C64(0x0080040800100080),
	C64(0x0080020400080080), C64(0x0080010200040080), C64(0x0080008001000200), C64(0x0080002040800100),
	C64(0x0000800020400080), C64(0x0000400020005000), C64(0x0000801000200080), C64(0x0000800800100080),
	C64(0x0000800400080080), C64(0x0000800200040080), C64(0x0000800100020080), C64(0x0000800040800100),
	C64(0x0000208000400080), C64(0x0000404000201000), C64(0x0000808010002000), C64(0x0000808008001000),
	C64(0x0000808004000800), C64(0x0000808002000400), C64(0x0000010100020004), C64(0x0000020000408104),
	C64(0x0000208080004000), C64(0x0000200040005000), C64(0x0000100080200080), C64(0x0000080080100080),
	C64(0x0000040080080080), C64(0x0000020080040080), C64(0x0000010080800200), C64(0x0000800080004100),
	C64(0x0000204000800080), C64(0x0000200040401000), C64(0x0000100080802000), C64(0x0000080080801000),
	C64(0x0000040080800800), C64(0x0000020080800400), C64(0x0000020001010004), C64(0x0000800040800100),
	C64(0x0000204000808000), C64(0x0000200040008080), C64(0x0000100020008080), C64(0x0000080010008080),
	C64(0x0000040008008080), C64(0x0000020004008080), C64(0x0000010002008080), C64(0x0000004081020004),
	C64(0x0000204000800080), C64(0x0000200040008080), C64(0x0000100020008080), C64(0x0000080010008080),
	C64(0x0000040008008080), C64(0x0000020004008080), C64(0x0000800100020080), C64(0x0000800041000080),
	C64(0x00FFFCDDFCED714A), C64(0x007FFCDDFCED714A), C64(0x003FFFCDFFD88096), C64(0x0000040810002101),
	C64(0x0001000204080011), C64(0x0001000204000801), C64(0x0001000082000401), C64(0x0001FFFAABFAD1A2)
};
const U64 magicmoves_r_mask[64]=
{	
	C64(0x000101010101017E), C64(0x000202020202027C), C64(0x000404040404047A), C64(0x0008080808080876),
	C64(0x001010101010106E), C64(0x002020202020205E), C64(0x004040404040403E), C64(0x008080808080807E),
	C64(0x0001010101017E00), C64(0x0002020202027C00), C64(0x0004040404047A00), C64(0x0008080808087600),
	C64(0x0010101010106E00), C64(0x0020202020205E00), C64(0x0040404040403E00), C64(0x0080808080807E00),
	C64(0x00010101017E0100), C64(0x00020202027C0200), C64(0x00040404047A0400), C64(0x0008080808760800),
	C64(0x00101010106E1000), C64(0x00202020205E2000), C64(0x00404040403E4000), C64(0x00808080807E8000),
	C64(0x000101017E010100), C64(0x000202027C020200), C64(0x000404047A040400), C64(0x0008080876080800),
	C64(0x001010106E101000), C64(0x002020205E202000), C64(0x004040403E404000), C64(0x008080807E808000),
	C64(0x0001017E01010100), C64(0x0002027C02020200), C64(0x0004047A04040400), C64(0x0008087608080800),
	C64(0x0010106E10101000), C64(0x0020205E20202000), C64(0x0040403E40404000), C64(0x0080807E80808000),
	C64(0x00017E0101010100), C64(0x00027C0202020200), C64(0x00047A0404040400), C64(0x0008760808080800),
	C64(0x00106E1010101000), C64(0x00205E2020202000), C64(0x00403E4040404000), C64(0x00807E8080808000),
	C64(0x007E010101010100), C64(0x007C020202020200), C64(0x007A040404040400), C64(0x0076080808080800),
	C64(0x006E101010101000), C64(0x005E202020202000), C64(0x003E404040404000), C64(0x007E808080808000),
	C64(0x7E01010101010100), C64(0x7C02020202020200), C64(0x7A04040404040400), C64(0x7608080808080800),
	C64(0x6E10101010101000), C64(0x5E20202020202000), C64(0x3E40404040404000), C64(0x7E80808080808000)
};

//my original tables for bishops
const unsigned int magicmoves_b_shift[64]=
{
	58, 59, 59, 59, 59, 59, 59, 58,
	59, 59, 59, 59, 59, 59, 59, 59,
	59, 59, 57, 57, 57, 57, 59, 59,
	59, 59, 57, 55, 55, 57, 59, 59,
	59, 59, 57, 55, 55, 57, 59, 59,
	59, 59, 57, 57, 57, 57, 59, 59,
	59, 59, 59, 59, 59, 59, 59, 59,
	58, 59, 59, 59, 59, 59, 59, 58
};

const U64 magicmoves_b_magics[64]=
{
	C64(0x0002020202020200), C64(0x0002020202020000), C64(0x0004010202000000), C64(0x0004040080000000),
	C64(0x0001104000000000), C64(0x0000821040000000), C64(0x0000410410400000), C64(0x0000104104104000),
	C64(0x0000040404040400), C64(0x0000020202020200), C64(0x0000040102020000), C64(0x0000040400800000),
	C64(0x0000011040000000), C64(0x0000008210400000), C64(0x0000004104104000), C64(0x0000002082082000),
	C64(0x0004000808080800), C64(0x0002000404040400), C64(0x0001000202020200), C64(0x0000800802004000),
	C64(0x0000800400A00000), C64(0x0000200100884000), C64(0x0000400082082000), C64(0x0000200041041000),
	C64(0x0002080010101000), C64(0x0001040008080800), C64(0x0000208004010400), C64(0x0000404004010200),
	C64(0x0000840000802000), C64(0x0000404002011000), C64(0x0000808001041000), C64(0x0000404000820800),
	C64(0x0001041000202000), C64(0x0000820800101000), C64(0x0000104400080800), C64(0x0000020080080080),
	C64(0x0000404040040100), C64(0x0000808100020100), C64(0x0001010100020800), C64(0x0000808080010400),
	C64(0x0000820820004000), C64(0x0000410410002000), C64(0x0000082088001000), C64(0x0000002011000800),
	C64(0x0000080100400400), C64(0x0001010101000200), C64(0x0002020202000400), C64(0x0001010101000200),
	C64(0x0000410410400000), C64(0x0000208208200000), C64(0x0000002084100000), C64(0x0000000020880000),
	C64(0x0000001002020000), C64(0x0000040408020000), C64(0x0004040404040000), C64(0x0002020202020000),
	C64(0x0000104104104000), C64(0x0000002082082000), C64(0x0000000020841000), C64(0x0000000000208800),
	C64(0x0000000010020200), C64(0x0000000404080200), C64(0x0000040404040400), C64(0x0002020202020200)
};


const U64 magicmoves_b_mask[64]=
{
	C64(0x0040201008040200), C64(0x0000402010080400), C64(0x0000004020100A00), C64(0x0000000040221400),
	C64(0x0000000002442800), C64(0x0000000204085000), C64(0x0000020408102000), C64(0x0002040810204000),
	C64(0x0020100804020000), C64(0x0040201008040000), C64(0x00004020100A0000), C64(0x0000004022140000),
	C64(0x0000000244280000), C64(0x0000020408500000), C64(0x0002040810200000), C64(0x0004081020400000),
	C64(0x0010080402000200), C64(0x0020100804000400), C64(0x004020100A000A00), C64(0x0000402214001400),
	C64(0x0000024428002800), C64(0x0002040850005000), C64(0x0004081020002000), C64(0x0008102040004000),
	C64(0x0008040200020400), C64(0x0010080400040800), C64(0x0020100A000A1000), C64(0x0040221400142200),
	C64(0x0002442800284400), C64(0x0004085000500800), C64(0x0008102000201000), C64(0x0010204000402000),
	C64(0x0004020002040800), C64(0x0008040004081000), C64(0x00100A000A102000), C64(0x0022140014224000),
	C64(0x0044280028440200), C64(0x0008500050080400), C64(0x0010200020100800), C64(0x0020400040201000),
	C64(0x0002000204081000), C64(0x0004000408102000), C64(0x000A000A10204000), C64(0x0014001422400000),
	C64(0x0028002844020000), C64(0x0050005008040200), C64(0x0020002010080400), C64(0x0040004020100800),
	C64(0x0000020408102000), C64(0x0000040810204000), C64(0x00000A1020400000), C64(0x0000142240000000),
	C64(0x0000284402000000), C64(0x0000500804020000), C64(0x0000201008040200), C64(0x0000402010080400),
	C64(0x0002040810204000), C64(0x0004081020400000), C64(0x000A102040000000), C64(0x0014224000000000),
	C64(0x0028440200000000), C64(0x0050080402000000), C64(0x0020100804020000), C64(0x0040201008040200)
};

#ifdef MINIMIZE_MAGIC
U64 magicmovesbdb[5248];
const U64* magicmoves_b_indices[64]=
{
	magicmovesbdb+4992, magicmovesbdb+2624,  magicmovesbdb+256,  magicmovesbdb+896,
	magicmovesbdb+1280, magicmovesbdb+1664, magicmovesbdb+4800, magicmovesbdb+5120,
	magicmovesbdb+2560, magicmovesbdb+2656,  magicmovesbdb+288,  magicmovesbdb+928,
	magicmovesbdb+1312, magicmovesbdb+1696, magicmovesbdb+4832, magicmovesbdb+4928,
	magicmovesbdb+0,     magicmovesbdb+128,  magicmovesbdb+320,  magicmovesbdb+960,
	magicmovesbdb+1344, magicmovesbdb+1728, magicmovesbdb+2304, magicmovesbdb+2432,
	magicmovesbdb+32,    magicmovesbdb+160,  magicmovesbdb+448, magicmovesbdb+2752,
	magicmovesbdb+3776, magicmovesbdb+1856, magicmovesbdb+2336, magicmovesbdb+2464,
	magicmovesbdb+64,    magicmovesbdb+192,  magicmovesbdb+576, magicmovesbdb+3264,
	magicmovesbdb+4288, magicmovesbdb+1984, magicmovesbdb+2368, magicmovesbdb+2496,
	magicmovesbdb+96,    magicmovesbdb+224,  magicmovesbdb+704, magicmovesbdb+1088,
	magicmovesbdb+1472, magicmovesbdb+2112, magicmovesbdb+2400, magicmovesbdb+2528,
	magicmovesbdb+2592, magicmovesbdb+2688,  magicmovesbdb+832, magicmovesbdb+1216,
	magicmovesbdb+1600, magicmovesbdb+2240, magicmovesbdb+4864, magicmovesbdb+4960,
	magicmovesbdb+5056, magicmovesbdb+2720,  magicmovesbdb+864, magicmovesbdb+1248,
	magicmovesbdb+1632, magicmovesbdb+2272, magicmovesbdb+4896, magicmovesbdb+5184
};
#else
	#ifndef PERFECT_MAGIC_HASH
		U64 magicmovesbdb[64][1<<9];
	#else
		U64 magicmovesbdb[1428];
		PERFECT_MAGIC_HASH magicmoves_b_indices[64][1<<9];
	#endif
#endif

#ifdef MINIMIZE_MAGIC
U64 magicmovesrdb[102400];
const U64* magicmoves_r_indices[64]=
{
	magicmovesrdb+86016, magicmovesrdb+73728, magicmovesrdb+36864, magicmovesrdb+43008,
	magicmovesrdb+47104, magicmovesrdb+51200, magicmovesrdb+77824, magicmovesrdb+94208,
	magicmovesrdb+69632, magicmovesrdb+32768, magicmovesrdb+38912, magicmovesrdb+10240,
	magicmovesrdb+14336, magicmovesrdb+53248, magicmovesrdb+57344, magicmovesrdb+81920,
	magicmovesrdb+24576, magicmovesrdb+33792,  magicmovesrdb+6144, magicmovesrdb+11264,
	magicmovesrdb+15360, magicmovesrdb+18432, magicmovesrdb+58368, magicmovesrdb+61440,
	magicmovesrdb+26624,  magicmovesrdb+4096,  magicmovesrdb+7168,     magicmovesrdb+0,
	 magicmovesrdb+2048, magicmovesrdb+19456, magicmovesrdb+22528, magicmovesrdb+63488,
	magicmovesrdb+28672,  magicmovesrdb+5120,  magicmovesrdb+8192,  magicmovesrdb+1024,
	 magicmovesrdb+3072, magicmovesrdb+20480, magicmovesrdb+23552, magicmovesrdb+65536,
	magicmovesrdb+30720, magicmovesrdb+34816,  magicmovesrdb+9216, magicmovesrdb+12288,
	magicmovesrdb+16384, magicmovesrdb+21504, magicmovesrdb+59392, magicmovesrdb+67584,
	magicmovesrdb+71680, magicmovesrdb+35840, magicmovesrdb+39936, magicmovesrdb+13312,
	magicmovesrdb+17408, magicmovesrdb+54272, magicmovesrdb+60416, magicmovesrdb+83968,
	magicmovesrdb+90112, magicmovesrdb+75776, magicmovesrdb+40960, magicmovesrdb+45056,
	magicmovesrdb+49152, magicmovesrdb+55296, magicmovesrdb+79872, magicmovesrdb+98304
};
#else
	#ifndef PERFECT_MAGIC_HASH
		U64 magicmovesrdb[64][1<<12];
	#else
		U64 magicmovesrdb[4900];
		PERFECT_MAGIC_HASH magicmoves_r_indices[64][1<<12];
	#endif
#endif

U64 initmagicmoves_occ(const int* squares, const int numSquares, const U64 linocc)
{
	int i;
	U64 ret=0;
	for(i=0;i<numSquares;i++)
		if(linocc&(((U64)(1))<<i)) ret|=(((U64)(1))<<squares[i]);
	return ret;
}

U64 initmagicmoves_Rmoves(const int square, const U64 occ)
{
	U64 ret=0;
	U64 bit;
	U64 rowbits=(((U64)0xFF)<<(8*(square/8)));
	
	bit=(((U64)(1))<<square);
	do
	{
		bit<<=8;
		ret|=bit;
	}while(bit && !(bit&occ));
	bit=(((U64)(1))<<square);
	do
	{
		bit>>=8;
		ret|=bit;
	}while(bit && !(bit&occ));
	bit=(((U64)(1))<<square);
	do
	{
		bit<<=1;
		if(bit&rowbits) ret|=bit;
		else break;
	}while(!(bit&occ));
	bit=(((U64)(1))<<square);
	do
	{
		bit>>=1;
		if(bit&rowbits) ret|=bit;
		else break;
	}while(!(bit&occ));
	return ret;
}

U64 initmagicmoves_Bmoves(const int square, const U64 occ)
{
	U64 ret=0;
	U64 bit;
	U64 bit2;
	U64 rowbits=(((U64)0xFF)<<(8*(square/8)));
	
	bit=(((U64)(1))<<square);
	bit2=bit;
	do
	{
		bit<<=8-1;
		bit2>>=1;
		if(bit2&rowbits) ret|=bit;
		else break;
	}while(bit && !(bit&occ));
	bit=(((U64)(1))<<square);
	bit2=bit;
	do
	{
		bit<<=8+1;
		bit2<<=1;
		if(bit2&rowbits) ret|=bit;
		else break;
	}while(bit && !(bit&occ));
	bit=(((U64)(1))<<square);
	bit2=bit;
	do
	{
		bit>>=8-1;
		bit2<<=1;
		if(bit2&rowbits) ret|=bit;
		else break;
	}while(bit && !(bit&occ));
	bit=(((U64)(1))<<square);
	bit2=bit;
	do
	{
		bit>>=8+1;
		bit2>>=1;
		if(bit2&rowbits) ret|=bit;
		else break;
	}while(bit && !(bit&occ));
	return ret;
}

//used so that the original indices can be left as const so that the compiler can optimize better

#ifndef PERFECT_MAGIC_HASH
	#ifdef MINIMIZE_MAGIC
		#define BmagicNOMASK2(square, occupancy) *(magicmoves_b_indices2[square]+(((occupancy)*magicmoves_b_magics[square])>>magicmoves_b_shift[square]))
		#define RmagicNOMASK2(square, occupancy) *(magicmoves_r_indices2[square]+(((occupancy)*magicmoves_r_magics[square])>>magicmoves_r_shift[square]))
	#else
		#define BmagicNOMASK2(square, occupancy) magicmovesbdb[square][((occupancy)*magicmoves_b_magics[square])>>MINIMAL_B_BITS_SHIFT(square)]
		#define RmagicNOMASK2(square, occupancy) magicmovesrdb[square][((occupancy)*magicmoves_r_magics[square])>>MINIMAL_R_BITS_SHIFT(square)]
	#endif
/*#else
	#define BmagicNOMASK2(square, occupancy) magicmovesbdb[magicmoves_b_indices[square][((occupancy)*magicmoves_b_magics[square])>>MINIMAL_B_BITS_SHIFT]]
	#define RmagicNOMASK2(square, occupancy) magicmovesrdb[magicmoves_r_indices[square][((occupancy)*magicmoves_r_magics[square])>>MINIMAL_R_BITS_SHIFT]]
*/
#endif

void initmagicmoves(void)
{
	int i;

	//for bitscans :
	//initmagicmoves_bitpos64_database[(x*C64(0x07EDD5E59A4E28C2))>>58]
	int initmagicmoves_bitpos64_database[64]={
	63,  0, 58,  1, 59, 47, 53,  2,
	60, 39, 48, 27, 54, 33, 42,  3,
	61, 51, 37, 40, 49, 18, 28, 20,
	55, 30, 34, 11, 43, 14, 22,  4,
	62, 57, 46, 52, 38, 26, 32, 41,
	50, 36, 17, 19, 29, 10, 13, 21,
	56, 45, 25, 31, 35, 16,  9, 12,
	44, 24, 15,  8, 23,  7,  6,  5};

#ifdef MINIMIZE_MAGIC
	//identical to magicmove_x_indices except without the const modifer
	U64* magicmoves_b_indices2[64]=
	{
		magicmovesbdb+4992, magicmovesbdb+2624,  magicmovesbdb+256,  magicmovesbdb+896,
		magicmovesbdb+1280, magicmovesbdb+1664, magicmovesbdb+4800, magicmovesbdb+5120,
		magicmovesbdb+2560, magicmovesbdb+2656,  magicmovesbdb+288,  magicmovesbdb+928,
		magicmovesbdb+1312, magicmovesbdb+1696, magicmovesbdb+4832, magicmovesbdb+4928,
		magicmovesbdb+0,     magicmovesbdb+128,  magicmovesbdb+320,  magicmovesbdb+960,
		magicmovesbdb+1344, magicmovesbdb+1728, magicmovesbdb+2304, magicmovesbdb+2432,
		magicmovesbdb+32,    magicmovesbdb+160,  magicmovesbdb+448, magicmovesbdb+2752,
		magicmovesbdb+3776, magicmovesbdb+1856, magicmovesbdb+2336, magicmovesbdb+2464,
		magicmovesbdb+64,    magicmovesbdb+192,  magicmovesbdb+576, magicmovesbdb+3264,
		magicmovesbdb+4288, magicmovesbdb+1984, magicmovesbdb+2368, magicmovesbdb+2496,
		magicmovesbdb+96,    magicmovesbdb+224,  magicmovesbdb+704, magicmovesbdb+1088,
		magicmovesbdb+1472, magicmovesbdb+2112, magicmovesbdb+2400, magicmovesbdb+2528,
		magicmovesbdb+2592, magicmovesbdb+2688,  magicmovesbdb+832, magicmovesbdb+1216,
		magicmovesbdb+1600, magicmovesbdb+2240, magicmovesbdb+4864, magicmovesbdb+4960,
		magicmovesbdb+5056, magicmovesbdb+2720,  magicmovesbdb+864, magicmovesbdb+1248,
		magicmovesbdb+1632, magicmovesbdb+2272, magicmovesbdb+4896, magicmovesbdb+5184
	};
	U64* magicmoves_r_indices2[64]=
	{
		magicmovesrdb+86016, magicmovesrdb+73728, magicmovesrdb+36864, magicmovesrdb+43008,
		magicmovesrdb+47104, magicmovesrdb+51200, magicmovesrdb+77824, magicmovesrdb+94208,
		magicmovesrdb+69632, magicmovesrdb+32768, magicmovesrdb+38912, magicmovesrdb+10240,
		magicmovesrdb+14336, magicmovesrdb+53248, magicmovesrdb+57344, magicmovesrdb+81920,
		magicmovesrdb+24576, magicmovesrdb+33792,  magicmovesrdb+6144, magicmovesrdb+11264,
		magicmovesrdb+15360, magicmovesrdb+18432, magicmovesrdb+58368, magicmovesrdb+61440,
		magicmovesrdb+26624,  magicmovesrdb+4096,  magicmovesrdb+7168,     magicmovesrdb+0,
		magicmovesrdb+2048,  magicmovesrdb+19456, magicmovesrdb+22528, magicmovesrdb+63488,
		magicmovesrdb+28672,  magicmovesrdb+5120,  magicmovesrdb+8192,  magicmovesrdb+1024,
		magicmovesrdb+3072,  magicmovesrdb+20480, magicmovesrdb+23552, magicmovesrdb+65536,
		magicmovesrdb+30720, magicmovesrdb+34816,  magicmovesrdb+9216, magicmovesrdb+12288,
		magicmovesrdb+16384, magicmovesrdb+21504, magicmovesrdb+59392, magicmovesrdb+67584,
		magicmovesrdb+71680, magicmovesrdb+35840, magicmovesrdb+39936, magicmovesrdb+13312,
		magicmovesrdb+17408, magicmovesrdb+54272, magicmovesrdb+60416, magicmovesrdb+83968,
		magicmovesrdb+90112, magicmovesrdb+75776, magicmovesrdb+40960, magicmovesrdb+45056,
		magicmovesrdb+49152, magicmovesrdb+55296, magicmovesrdb+79872, magicmovesrdb+98304
	};
#endif // MINIMIZE_MAGIC


#ifdef PERFECT_MAGIC_HASH
	for(i=0;i<1428;i++)
		magicmovesbdb[i]=0;
	for(i=0;i<4900;i++)
		magicmovesrdb[i]=0;
#endif

	for(i=0;i<64;i++)
	{
		int squares[64];
		int numsquares=0;
		U64 temp=magicmoves_b_mask[i];
		while(temp)
		{
			U64 bit=temp&-temp;
			squares[numsquares++]=initmagicmoves_bitpos64_database[(bit*C64(0x07EDD5E59A4E28C2))>>58];
			temp^=bit;
		}
		for(temp=0;temp<(((U64)(1))<<numsquares);temp++)
		{
			U64 tempocc=initmagicmoves_occ(squares,numsquares,temp);
			#ifndef PERFECT_MAGIC_HASH
				BmagicNOMASK2(i,tempocc)=initmagicmoves_Bmoves(i,tempocc);
			#else
				U64 moves=initmagicmoves_Bmoves(i,tempocc);
				U64 index=(((tempocc)*magicmoves_b_magics[i])>>MINIMAL_B_BITS_SHIFT);
				int j;
				for(j=0;j<1428;j++)
				{
					if(!magicmovesbdb[j])
					{
						magicmovesbdb[j]=moves;
						magicmoves_b_indices[i][index]=j;
						break;
					}
					else if(magicmovesbdb[j]==moves)
					{
						magicmoves_b_indices[i][index]=j;
						break;
					}
				}
			#endif
		}
	}
	for(i=0;i<64;i++)
	{
		int squares[64];
		int numsquares=0;
		U64 temp=magicmoves_r_mask[i];
		while(temp)
		{
			U64 bit=temp&-temp;
			squares[numsquares++]=initmagicmoves_bitpos64_database[(bit*C64(0x07EDD5E59A4E28C2))>>58];
			temp^=bit;
		}
		for(temp=0;temp<(((U64)(1))<<numsquares);temp++)
		{
			U64 tempocc=initmagicmoves_occ(squares,numsquares,temp);
			#ifndef PERFECT_MAGIC_HASH
				RmagicNOMASK2(i,tempocc)=initmagicmoves_Rmoves(i,tempocc);
			#else
				U64 moves=initmagicmoves_Rmoves(i,tempocc);
				U64 index=(((tempocc)*magicmoves_r_magics[i])>>MINIMAL_R_BITS_SHIFT);
				int j;
				for(j=0;j<4900;j++)
				{
					if(!magicmovesrdb[j])
					{
						magicmovesrdb[j]=moves;
						magicmoves_r_indices[i][index]=j;
						break;
					}
					else if(magicmovesrdb[j]==moves)
					{
						magicmoves_r_indices[i][index]=j;
						break;
					}
				}
			#endif
		}
	}
}

================
File: setup.py
================
from pybind11.setup_helpers import Pybind11Extension, build_ext
from setuptools import setup

ext_modules = [
    Pybind11Extension(
        "chess_engine",
        [
            "magicmoves.c",           # Add the magic moves implementation
            "bitboard.cpp",
            "python_bindings.cpp"
        ],
        cxx_std=17,
        define_macros=[("MINIMIZE_MAGIC", None)],  # Use compact magic tables
    ),
]

setup(
    name="chess_engine",
    ext_modules=ext_modules,
    cmdclass={"build_ext": build_ext},
)

================
File: example.py
================
import chess_engine

# Create board and set starting position
board = chess_engine.ChessBitboard()
board.set_starting_position()

# Generate legal moves
moves = board.generate_legal_moves()
print(f"Found {len(moves)} legal moves")

# Make a move
if moves:
    board.make_move(moves[0])
    print("Made first legal move")

================
File: python_bindings.cpp
================
// python_bindings.cpp
#include <pybind11/pybind11.h>
#include <pybind11/stl.h>
#include "bitboard.h"

namespace py = pybind11;

PYBIND11_MODULE(chess_engine, m) {
    m.doc() = "Fast chess engine with magic bitboards";
    
    py::class_<Move>(m, "Move")
        .def(py::init<>())
        .def(py::init<int, int, int>())
        .def_readwrite("from_square", &Move::from_square)
        .def_readwrite("to_square", &Move::to_square)
        .def_readwrite("piece_type", &Move::piece_type);

    py::class_<ChessBitboard>(m, "ChessBitboard")
        .def(py::init<>())
        .def("set_starting_position", &ChessBitboard::setStartingPosition)
        .def("get_piece_at", &ChessBitboard::getPieceAt)
        .def("generate_legal_moves", &ChessBitboard::generateLegalMoves)
        .def("make_move", &ChessBitboard::makeMove)
        .def("get_white_pieces", &ChessBitboard::getWhitePieces)
        .def("get_black_pieces", &ChessBitboard::getBlackPieces);
}

================
File: magicmoves_wrapper.h
================
#pragma once
#include "types.h"

extern "C" {
    #include "magicmoves.h"
}

class MagicMoves {
public:
    static void init() {
        initmagicmoves();
    }
    
    static Bitboard getRookAttacks(Square square, Bitboard occupancy) {
        return Rmagic(square, occupancy);
    }
    
    static Bitboard getBishopAttacks(Square square, Bitboard occupancy) {
        return Bmagic(square, occupancy);
    }
    
    static Bitboard getQueenAttacks(Square square, Bitboard occupancy) {
        return Qmagic(square, occupancy);
    }
};

================
File: move.h
================
// Simple Move structure
#pragma once
#include "types.h"

struct Move {
    int from_square;
    int to_square;
    int piece_type;
    int capture_piece;
    bool is_promotion;
    int promotion_piece;
    
    Move() : from_square(0), to_square(0), piece_type(0), capture_piece(0), 
             is_promotion(false), promotion_piece(0) {}
    
    Move(int from, int to, int piece = 0) 
        : from_square(from), to_square(to), piece_type(piece), capture_piece(0),
          is_promotion(false), promotion_piece(0) {}

    Square from() const { return from_square; }
    Square to() const { return to_square; }

};

================
File: position.cpp
================
#include "bitboard.cpp"
#include "piece.cpp"

class Position {
    private:
        Bitboard piece_bb[6];
        Bitboard color_bb[2];
        Piece board[64]; // mailbox , double check if this is actually efficient later
        Color side_to_move;

    public:
        Piece get_piece(int square) const {
            return board[square];
        }
        Color get_side_to_move() const {
            return side_to_move;
        }

        std::vector<Move> Position::generateLegalMoves() const {
            //use magic bitboard to generate pseudo legal moves
            // we then check if the move is legal, and if it is, we add it to the list of legal moves
            std::vector<Move> pseudo_legal = generatePseudoLegalMoves();
            std::vector<Move> legal_moves;
            legal_moves.reserve(pseudo_legal.size());
            
            Square king_square = __builtin_ctzll(pieces_bb[KING] & color_bb[side_to_move]);
            Bitboard pinned_pieces = getPinnedPieces(side_to_move);
            Bitboard checkers = getCheckers();
            
            for (const Move& move : pseudo_legal) {
                if (isLegalMove(move, king_square, pinned_pieces, checkers)) {
                    legal_moves.push_back(move);
                }
            }
            
            return legal_moves;
        }

        template<PieceType PT>
        void Position::generatePieceMoves(std::vector<Move>& moves, Bitboard targets) const {
            Bitboard pieces = pieces_bb[PT] & color_bb[side_to_move];
            Bitboard occupied = color_bb[WHITE] | color_bb[BLACK];
            
            while (pieces) {
                Square from = pop_lsb(pieces);
                Bitboard attacks;
                
                if constexpr (PT == BISHOP) {
                    attacks = BishopAttacks[from][magic_index<BISHOP>(from, occupied)];
                } else if constexpr (PT == ROOK) {
                    attacks = RookAttacks[from][magic_index<ROOK>(from, occupied)];
                } else {  // QUEEN
                    attacks = BishopAttacks[from][magic_index<BISHOP>(from, occupied)] |
                            RookAttacks[from][magic_index<ROOK>(from, occupied)];
                }
                
                attacks &= targets;
                while (attacks) {
                    Square to = pop_lsb(attacks);
                    moves.emplace_back(from, to, NORMAL);
                }
            }
        }

        void Position::makeMove(const Move& move){
            StateInfo* new_state = ++state_info;
            *new_state = *(new_state-1);

            int from = move.from_square;
            int to = move.to_square;
            Piece move_piece = board[from];
            Piece captured_piece = board[to];

            // Incremental hash update
            // TO-DO
            uint64_t& hash_key = new_state->hash_key;
            hash_key ^= zobrist_psq[moving_piece][from];
            hash_key ^= zobrist_psq[moving_piece][to];
            
            if (captured_piece != NO_PIECE) {
                remove_piece(to, captured_piece);
                hash_key ^= zobrist_psq[captured_piece][to];
            }
            
            move_piece(from, to, moving_piece);
            
            // Handle special moves (castling, en passant, promotion)
            //TO-DO
            handle_special_moves(move);
            
            side_to_move = ~side_to_move;
            hash_key ^= zobrist_side;
            new_state->checkers = getAttackers(king_square(side_to_move), ~side_to_move);
        }


}
